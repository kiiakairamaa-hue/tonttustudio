
<script>
(function(){
  'use strict';

  /* -------------------- Asetukset ja vakiot -------------------- */
  const MAX_LONG_EDGE = 3000;
  const BG_MIN = 0.2, BG_MAX = 6.0;
  const STICKER_MIN = 0.4, STICKER_MAX = 10.0;
  const BASE_STICKER = 300;

  /* -------------------- DOM-viittaukset -------------------- */
  const file = document.getElementById('file');
  const save = document.getElementById('save');
  const clearBtn = document.getElementById('clear');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  const preview = document.getElementById('preview');

  /* -------------------- Back buffer -------------------- */
  const back = document.createElement('canvas');
  back.width = canvas.width;
  back.height = canvas.height;
  const bctx = back.getContext('2d', {alpha:false});

  /* -------------------- Tilamuuttujat -------------------- */
  let saveCount = 1;
  let bgBitmap = null;
  let bg = { x:0, y:0, scale:1 };
  let bgLocked = false;

  let stickers = [];
  let activeIndex = -1;

  let needsRedraw = true;
  let pointers = new Map();
  let draggingBG = false;
  let stickerGesture = null;

  /* -------------------- Poistonappi -------------------- */
  const delBtn = document.createElement('div');
  delBtn.className = 'remove-btn';
  delBtn.textContent = 'x';
  delBtn.style.display = 'none';
  preview.appendChild(delBtn);

  delBtn.addEventListener('click', ()=>{
    if(activeIndex >= 0){
      stickers.splice(activeIndex,1);
      activeIndex = stickers.length-1;
      if(stickers.length === 0) bgLocked = false;
      needsRedraw = true;
      updateDeleteButtonPosition();
    }
  });

  /* -------------------- Piirtosilmukka -------------------- */
  requestAnimationFrame(function loop(){
    if(needsRedraw){
      draw();
      needsRedraw = false;
    }
    requestAnimationFrame(loop);
  });

  /* -------------------- Piirron apufunktiot -------------------- */
  function clearCanvas(t){ t.fillStyle='#000'; t.fillRect(0,0,canvas.width,canvas.height); }

  clearCanvas(ctx);
  clearCanvas(bctx);

  /* -------------------- Kuvan avaus -------------------- */
  async function decodeSmart(f){
    if('createImageBitmap' in window){
      try{
        return await createImageBitmap(f,{imageOrientation:'from-image',premultiplyAlpha:'premultiply'});
      }catch(_){}
    }
    return await new Promise((res,rej)=>{
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload=()=>{URL.revokeObjectURL(url);res(img)};
      img.onerror=rej;
      img.src=url;
    });
  }

  function downscaleToMaxEdge(bitmap){
    const iw=bitmap.width, ih=bitmap.height;
    const k = Math.min(MAX_LONG_EDGE/Math.max(iw,ih),1);
    const ow=Math.round(iw*k), oh=Math.round(ih*k);
    const off=document.createElement('canvas');
    off.width=ow; off.height=oh;
    const g=off.getContext('2d');
    g.imageSmoothingEnabled=true; g.imageSmoothingQuality='high';
    g.drawImage(bitmap,0,0,ow,oh);
    return off;
  }

  function fitContain(){
    const cw=canvas.width, ch=canvas.height, iw=bgBitmap.width, ih=bgBitmap.height;
    const s=Math.min(cw/iw, ch/ih);
    bg.scale=s;
    bg.x=(cw-iw*s)/2;
    bg.y=(ch-ih*s)/2;
  }

  function clampBgScale(){
    const cw=canvas.width, ch=canvas.height;
    const contain=Math.min(cw/(bgBitmap?.width||cw), ch/(bgBitmap?.height||ch));
    bg.scale=Math.max(contain*BG_MIN, Math.min(BG_MAX, bg.scale));
  }

  /* -------------------- Varsinainen render -------------------- */
  function renderTo(targetCtx){
    targetCtx.fillStyle='#000';
    targetCtx.fillRect(0,0,canvas.width,canvas.height);

    if(bgBitmap){
      targetCtx.save();
      targetCtx.imageSmoothingEnabled=true;
      targetCtx.imageSmoothingQuality='high';
      targetCtx.translate(bg.x,bg.y);
      targetCtx.scale(bg.scale,bg.scale);
      targetCtx.drawImage(bgBitmap,0,0);
      targetCtx.restore();
    }

    for(let i=0;i<stickers.length;i++){
      const st = stickers[i];
      targetCtx.save();
      targetCtx.translate(st.x, st.y);
      targetCtx.rotate(st.rot);
      const img = st.bitmap;
      const w = img.width, h = img.height;
      const inner = Math.min(BASE_STICKER/w, BASE_STICKER/h) * st.scale;
      targetCtx.scale(inner, inner);
      targetCtx.drawImage(img, -w/2, -h/2);
      targetCtx.restore();
    }
  }

  /* -------------------- Outline aktiiviselle -------------------- */
  function roundedRectPath(g, x, y, w, h, r){
    const rr=Math.min(r, Math.abs(w)/2, Math.abs(h)/2);
    g.beginPath();
    g.moveTo(x+rr,y);
    g.lineTo(x+w-rr,y);
    g.quadraticCurveTo(x+w,y,x+w,y+rr);
    g.lineTo(x+w,y+h-rr);
    g.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    g.lineTo(x+rr,y+h);
    g.quadraticCurveTo(x,y+h,x,y+h-rr);
    g.lineTo(x,y+rr);
    g.quadraticCurveTo(x,y,x+rr,y);
    g.closePath();
  }

  function drawOutline(){
    if(activeIndex<0) return;
    const st = stickers[activeIndex];
    const img = st.bitmap;
    const w = img.width, h = img.height;
    const inner = Math.min(BASE_STICKER/w, BASE_STICKER/h) * st.scale;

    ctx.save();
    ctx.translate(st.x, st.y);
    ctx.rotate(st.rot);
    ctx.scale(inner, inner);

    ctx.lineWidth = 3 / inner;
    ctx.strokeStyle = '#f6d778';
    ctx.shadowColor='rgba(246,215,120,.35)';
    ctx.shadowBlur=14;

    roundedRectPath(ctx, -w/2, -h/2, w, h, Math.min(w,h)*0.12);
    ctx.stroke();
    ctx.restore();

    updateDeleteButtonPosition();
  }

  /* -------------------- Draw (näkyvä päivitys) -------------------- */
  function draw(){
    renderTo(bctx);
    ctx.drawImage(back,0,0);
    drawOutline();
  }

  /* -------------------- Delete-napin sijainti -------------------- */
  function updateDeleteButtonPosition(){
    if(activeIndex<0){ delBtn.style.display='none'; return; }
    delBtn.style.display='block';

    const st = stickers[activeIndex];
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / canvas.width;
    const scaleY = rect.height / canvas.height;

    const img = st.bitmap, w=img.width, h=img.height;
    const inner = Math.min(BASE_STICKER/w, BASE_STICKER/h)*st.scale;

    const px = (st.x + (w/2)*inner)*scaleX + rect.left;
    const py = (st.y - (h/2)*inner)*scaleY + rect.top;

    const pr = preview.getBoundingClientRect();
    delBtn.style.left = (px - pr.left + 6) + 'px';
    delBtn.style.top  = (py - pr.top  - 6) + 'px';
  }

  /* -------------------- Kuvan avaus -------------------- */
  file.addEventListener('change', async (e)=>{
    const f=e.target.files && e.target.files[0];
    if(!f) return;

    const label = document.querySelector('label[for="file"]');
    const original = label.textContent;
    label.textContent="LATAAN...";
    label.style.opacity="0.6";
    label.style.pointerEvents="none";

    try{
      const isHeic = (/\.hei[cf]$/i.test(f.name||'') || /heic|heif/i.test(f.type||''));

      if(isHeic && window.heic2any){
        const pngBlob = await window.heic2any({blob:f,toType:'image/png'});
        const url = URL.createObjectURL(pngBlob);

        const img = await new Promise((res,rej)=>{
          const im=new Image();
          im.onload=()=>res(im);
          im.onerror=rej;
          im.src=url;
        });

        URL.revokeObjectURL(url);

        const off=document.createElement('canvas');
        off.width = img.naturalWidth;
        off.height = img.naturalHeight;
        const g=off.getContext('2d');
        g.drawImage(img,0,0);
        bgBitmap = downscaleToMaxEdge(off);

      }else{
        const bmp = await decodeSmart(f);
        bgBitmap = downscaleToMaxEdge(bmp);
      }

      fitContain();
      clampBgScale();
      needsRedraw = true;

    }catch{
      alert("Kuvan avaaminen epäonnistui.");
    }finally{
      e.target.value="";
      label.textContent = original;
      label.style.opacity="1";
      label.style.pointerEvents="auto";
    }
  });

  /* -------------------- Stickerit -------------------- */
  window.addEventListener('load', ()=>{
    const thumbs = document.getElementById('thumbs');
    if(!thumbs) return;

    async function addStickerFromUrl(url){
      const img = new Image();
      img.crossOrigin = "anonymous";   // ★ tärkein korjaus ★

      await new Promise((res,rej)=>{
        img.onload=res;
        img.onerror=rej;
        img.src=url;
      });

      const off=document.createElement('canvas');
      off.width=img.naturalWidth;
      off.height=img.naturalHeight;

      const g=off.getContext('2d');
      g.drawImage(img,0,0);

      stickers.push({
        bitmap:off,
        x:canvas.width/2,
        y:canvas.height/2,
        scale:1,
        rot:0
      });

      activeIndex = stickers.length-1;
      bgLocked = true;
      needsRedraw = true;
      updateDeleteButtonPosition();
    }

    thumbs.addEventListener('click', async (e)=>{
      if(e.target.tagName!=='IMG') return;
      addStickerFromUrl(e.target.src);
    });
  });

  /* -------------------- Tallennus -------------------- */
  save.addEventListener('click', ()=>{
    const off=document.createElement('canvas');
    off.width=canvas.width;
    off.height=canvas.height;
    const g=off.getContext('2d',{alpha:false});

    renderTo(g);

    const filename = `Joulugeneraattori_${String(saveCount).padStart(3,'0')}.png`;
    saveCount++;

    off.toBlob((blob)=>{
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=filename;
      a.target="_blank";   // Android/iOS yhteensopivuus

      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{
        URL.revokeObjectURL(a.href);
        a.remove();
      },1000);
    });
  });

  /* -------------------- Tyhjennä -------------------- */
  clearBtn.addEventListener('click', resetAll);
  
})();
</script>
